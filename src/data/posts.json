[
  {
    "slug": "0000-ABOUT",
    "title": "TEST",
    "date": "2025-10-20",
    "content": "<h1>딩딩딩딩딩</h1>\n<p><img src=\"/posts/0000-ABOUT/images/cover.png\" alt=\"테스트 이미지\"></p>\n",
    "imagesPath": "/posts/0000-ABOUT/images/"
  },
  {
    "slug": "2025-10-28-TEST",
    "title": "TEST",
    "date": "2025-10-20",
    "summary": "테스트 원",
    "type": "Projects",
    "category": "UX/UI",
    "tags": ["app", "habit", "design"],
    "content": "<h1>마크다운 파일</h1>\n<h2>들어가기 전</h2>\n<p>ㅋㅋ</p>\n<ol>\n<li>넘버링 테스트</li>\n<li>넘버링 테스트</li>\n<li>넘버링 테스트</li>\n</ol>\n<ul>\n<li>닷 테스트</li>\n<li>닷 테스트</li>\n</ul>\n<pre><code class=\"language-js\">// 코드 작성 테스트\r\nconsole.log(\"hello world!\");\n</code></pre>\n<pre><code class=\"language-js\">const run = async () => {\r\n  const posts = await getPosts();\r\n  fs.mkdirSync(path.dirname(OUTPUT), { recursive: true });\r\n  fs.writeFileSync(OUTPUT, JSON.stringify(posts, null, 2));\r\n  console.log(\"✅ posts.json generated:\", OUTPUT);\r\n};\r\n\r\nrun();\n</code></pre>\n<ul>\n<li>[ ] 가나다</li>\n<li>[ ] 가나다</li>\n</ul>\n<p><img src=\"https://i.namu.wiki/i/XDH2CDz5hQ_safBefBCvz7NOl8fiXoMg0HSIqhogw9XczaoE8N6rp9pS6Jz--_w8tX69eXr8NRRzUzUwnT-YPg.webp\" alt=\"이미지 테스트\"></p>\n",
    "imagesPath": "/posts/2025-10-28-TEST/images/"
  },
  {
    "slug": "2025-10-28-TEST2",
    "title": "TEST2",
    "date": "2025-10-29",
    "summary": "테스트 투",
    "type": "Projects",
    "category": "UX/UI",
    "tags": ["app", "habit", "design"],
    "content": "",
    "imagesPath": "/posts/2025-10-28-TEST2/images/"
  },
  {
    "slug": "2025-10-30-closure",
    "title": "[자바스크립트 딥다이브] 24장: 클로저",
    "date": "2025-10-29",
    "summary": "콜백함수, 렉시컬 환경, 외부참조 그리고 클로저 LET'S GO",
    "type": "Blog",
    "category": "Study",
    "tags": ["app", "habit", "design"],
    "content": "<h1>콜백함수, 렉시컬 환경, 외부참조 그리고 클로저 LET'S GO</h1>\n<h2>들어가기 전</h2>\n<p>자바스크립트 딥다이브 24장을 읽기 전, <code>함수와 일급 객체</code>, <code>실행 컨텍스트</code>를 읽으며 함수를 매개변수로 전달하며 생기는 일, 렉시컬 환경과 외부 참조에 대해서 공부했다. 이번에 공부한 <code>클로저</code>는 이전 내용들의 개념을 다시 한 번 복습하면, 완벽히 이해가 될 것 같아 차근차근 공부한 순서대로 글을 작성해보려 한다.</p>\n<h2>(복습) 콜백함수</h2>\n<p>콜백 함수는 자바스크립트에서 함수가 가지는 중요한 특성에서 출발한다. 자바스크립트에서 함수는 숫자, 문자열, 객체 등과 마찬가지로 또 다른 함수의 매개변수로 전달될 수 있다. 이렇게 다른 함수의 인자로 전달되는 함수를 <code>콜백 함수</code>라고 부른다.</p>\n<p>\"야, 내가 함수 하나 전달한테니 나중에 네가 알아서 불러 줘\"</p>\n<pre><code class=\"language-js\">function main(x) {\r\n  x();\r\n}\r\n\r\nfunction sayHi() {\r\n  console.log(\"안녕\");\r\n}\r\n\r\nmain(sayHi); // 출력: 안녕\n</code></pre>\n<p>콜백 함수가 언제, 어떻게 호출될지는 콜백 함수를 전달받은 함수의 내부 구현 사항에 달려 있다. 특히, 코드의 유연성을 높이고 비동기 처리에 강력한 장점을 가진다..</p>\n<ol>\n<li>동적으로 기능을 변경하기: 하나의 함수에 어떤 콜백 함수를 전달하느냐에 따라 마치 부품을 갈아 끼우듯 다른 기능을 수행하는 것</li>\n</ol>\n<pre><code class=\"language-js\">function greetToUser(greet) {\r\n  const name = \"성훈\";\r\n  greet(name);\r\n}\r\n\r\nfunction greetInKorean(name) {\r\n  console.log(name + \"님, 안녕하세요\");\r\n}\r\n\r\nfunction greetInEnglish(name) {\r\n  console.log(\"hi, \" + name);\r\n}\r\n\r\ngreetToUser(greetInKorean); // 출력: 성훈님, 안녕하세요\r\ngreetToUser(greetInEnglish); // 출력: hi, 성훈\n</code></pre>\n<ol start=\"2\">\n<li>비동기 처리하기: <code>setTimeout</code> 함수와 같이 첫번 째 인자로 받은 콜백 함수를 받아 일정 시간이 지난 후 해당 콜백 함수를 호출하는 것</li>\n</ol>\n<h2>(복습) 렉시컬 환경과 외부 참조</h2>\n<p>렉시컬 환경은 자바스크립트 엔진이 함수나 블록 코드를 실행하기 위해 필요한 환경 정보를 모아 놓은 객체.</p>\n<ol>\n<li>현재 스코프 내의 변수 및 함수 선언</li>\n<li>외부 환경에 대한 참조 <code>Outer Lexical Environment Reference</code></li>\n</ol>\n<p>자바스크립트는 함수가 어디서 호출되었는지가 아니라, 어디서 정의되었는지를 기준으로 외부 스코프를 결정한다. 함수가 정의된 물리적 위치의 상위 스코프가 해당 함수의 외부 환경 참조 값으로 영구히 저장된다.</p>\n<p>이 외부 참조 값이 바로 클로저 동작 원리가 되는 상위 스코프에 대한 연결 고리가 되며, 이 연결 고리를 따라 상위 스코프 변수에 접근하는 것을 스코프 체인이라고 한다.</p>\n<h2>클로저</h2>\n<p>외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 부른다.</p>\n<p>책에서는 클로저라고 부를 수 있는 2가지 조건을 다음과 같이 나타낸다.</p>\n<pre><code>1. 중첩 함수가 상위 스코프의 식별자를 참조해야 한다.\r\n2. 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정한다.\n</code></pre>\n<ol>\n<li>함수가 외부 스코프의 변수를 참조해야 한다.</li>\n<li>함수가 자신의 정의된 스코프 밖에서 호출되어야 한다.</li>\n</ol>\n<p>즉, 함수가 자신의 렉시컬 환경(정의된 스코프) 밖에서 호출되었을 때, 자신의 렉시컬 환경에 접근할 수 있는 현상.. (외부 참조 값을 통해 변수에 접근한다.)</p>\n<h2>🧐 떡밥회수</h2>\n<p>떡밥 회수의 시간. 이전에 <code>함수와 일급 객체</code>를 공부할 때에, 생성자 함수에 함수를 매개변수로 전달하여 이벤트 발생 시, 부모 요소에 있는 <code>sortOption</code> 값을 변경하는 예제를 기억하는가?</p>\n<pre><code class=\"language-js\">// index.js\r\nlet sortOption = \"최신순\";\r\n\r\nconst sortSelect = new SortSelect(onSortChange);\r\n\r\nfunction onSortChange(newValue) {\r\n  sortOption = newValue; // 부모 상태 갱신\r\n  console.log(\"새 정렬 옵션:\", sortOption);\r\n}\r\n\r\nsortSelect.triggerChange(\"인기순\"); // 자식이 이벤트 발생을 흉내냄\n</code></pre>\n<pre><code class=\"language-js\">// SortSelect.js\r\nfunction SortSelect(onSortChange) {\r\n  // 이벤트 발생 시...\r\n  this.triggerChange = (value) => {\r\n    onSortChange(value); // 부모가 준 콜백 실행\r\n  };\r\n}\n</code></pre>\n<p>클로저는 함수가 정의된 곳과 함수가 실행되는 곳이 물리적으로 분리되었을 때 발생하는 현상이다.</p>\n<ol>\n<li><code>onSortChange</code> 함수가 상위 스코프의 <code>sortOption</code>을 참조한다.</li>\n<li><code>onSortChange</code> 함수는 최상위 스코프에 정의되었지만, 개념적으로 <code>SortSelect</code> 객체의 속성으로 캡슐화되어 보관된다. 함수 실행 주기를 넘어, 인스턴스가 존재하는 한 객체의 생명 주기로 유지된다.</li>\n</ol>\n<h2>결론</h2>\n<p>콜백 함수는 클로저를 사용하는 하나의 방식이고, 클로저가 모두 콜백 함수의 형태를 하고 있는 것은 아니다.</p>\n<ol>\n<li>함수는 정의된 위치의 상위 스코프를 외부 참조값으로 기억한다.</li>\n<li>함수를 다른 함수의 인자로 전달할 수 있으며, 이를 콜백함수라 부른다.</li>\n<li>클로저는 함수가 정의된 스코프 밖에서 호출되더라도, 외부 스코프 변수에 접근할 수 있는 현상이며, 콜백 함수에서 많이 볼 수 있는 패턴이다.</li>\n</ol>\n<p>함수의 다양한 형태를 공부할 때, <code>콜백 함수 == 클로저</code> 라고 얕게 이해하고 넘어갔는데, 이제서야 해당 개념의 차이를 설명할 수 있게 되었다!</p>\n",
    "imagesPath": "/posts/2025-10-30-closure/images/"
  },
  {
    "slug": "0000-ABOUT",
    "title": "TEST",
    "date": "2025-10-20",
    "content": "<h1>딩딩딩딩딩</h1>\n<p><img src=\"/posts/0000-ABOUT/images/cover.png\" alt=\"테스트 이미지\"></p>\n",
    "imagesPath": "/posts/0000-ABOUT/images/"
  },
  {
    "slug": "2025-10-28-TEST",
    "title": "TEST",
    "date": "2025-10-20",
    "summary": "테스트 원",
    "type": "Projects",
    "category": "UX/UI",
    "tags": ["app", "habit", "design"],
    "content": "<h1>마크다운 파일</h1>\n<h2>들어가기 전</h2>\n<p>ㅋㅋ</p>\n<ol>\n<li>넘버링 테스트</li>\n<li>넘버링 테스트</li>\n<li>넘버링 테스트</li>\n</ol>\n<ul>\n<li>닷 테스트</li>\n<li>닷 테스트</li>\n</ul>\n<pre><code class=\"language-js\">// 코드 작성 테스트\r\nconsole.log(\"hello world!\");\n</code></pre>\n<pre><code class=\"language-js\">const run = async () => {\r\n  const posts = await getPosts();\r\n  fs.mkdirSync(path.dirname(OUTPUT), { recursive: true });\r\n  fs.writeFileSync(OUTPUT, JSON.stringify(posts, null, 2));\r\n  console.log(\"✅ posts.json generated:\", OUTPUT);\r\n};\r\n\r\nrun();\n</code></pre>\n<ul>\n<li>[ ] 가나다</li>\n<li>[ ] 가나다</li>\n</ul>\n<p><img src=\"https://i.namu.wiki/i/XDH2CDz5hQ_safBefBCvz7NOl8fiXoMg0HSIqhogw9XczaoE8N6rp9pS6Jz--_w8tX69eXr8NRRzUzUwnT-YPg.webp\" alt=\"이미지 테스트\"></p>\n",
    "imagesPath": "/posts/2025-10-28-TEST/images/"
  },
  {
    "slug": "2025-10-28-TEST2",
    "title": "TEST2",
    "date": "2025-10-29",
    "summary": "테스트 투",
    "type": "Projects",
    "category": "UX/UI",
    "tags": ["app", "habit", "design"],
    "content": "",
    "imagesPath": "/posts/2025-10-28-TEST2/images/"
  },
  {
    "slug": "2025-10-30-closure",
    "title": "[자바스크립트 딥다이브] 24장: 클로저",
    "date": "2025-10-29",
    "summary": "콜백함수, 렉시컬 환경, 외부참조 그리고 클로저 LET'S GO",
    "type": "Blog",
    "category": "Study",
    "tags": ["app", "habit", "design"],
    "content": "<h1>콜백함수, 렉시컬 환경, 외부참조 그리고 클로저 LET'S GO</h1>\n<h2>들어가기 전</h2>\n<p>자바스크립트 딥다이브 24장을 읽기 전, <code>함수와 일급 객체</code>, <code>실행 컨텍스트</code>를 읽으며 함수를 매개변수로 전달하며 생기는 일, 렉시컬 환경과 외부 참조에 대해서 공부했다. 이번에 공부한 <code>클로저</code>는 이전 내용들의 개념을 다시 한 번 복습하면, 완벽히 이해가 될 것 같아 차근차근 공부한 순서대로 글을 작성해보려 한다.</p>\n<h2>(복습) 콜백함수</h2>\n<p>콜백 함수는 자바스크립트에서 함수가 가지는 중요한 특성에서 출발한다. 자바스크립트에서 함수는 숫자, 문자열, 객체 등과 마찬가지로 또 다른 함수의 매개변수로 전달될 수 있다. 이렇게 다른 함수의 인자로 전달되는 함수를 <code>콜백 함수</code>라고 부른다.</p>\n<p>\"야, 내가 함수 하나 전달한테니 나중에 네가 알아서 불러 줘\"</p>\n<pre><code class=\"language-js\">function main(x) {\r\n  x();\r\n}\r\n\r\nfunction sayHi() {\r\n  console.log(\"안녕\");\r\n}\r\n\r\nmain(sayHi); // 출력: 안녕\n</code></pre>\n<p>콜백 함수가 언제, 어떻게 호출될지는 콜백 함수를 전달받은 함수의 내부 구현 사항에 달려 있다. 특히, 코드의 유연성을 높이고 비동기 처리에 강력한 장점을 가진다..</p>\n<ol>\n<li>동적으로 기능을 변경하기: 하나의 함수에 어떤 콜백 함수를 전달하느냐에 따라 마치 부품을 갈아 끼우듯 다른 기능을 수행하는 것</li>\n</ol>\n<pre><code class=\"language-js\">function greetToUser(greet) {\r\n  const name = \"성훈\";\r\n  greet(name);\r\n}\r\n\r\nfunction greetInKorean(name) {\r\n  console.log(name + \"님, 안녕하세요\");\r\n}\r\n\r\nfunction greetInEnglish(name) {\r\n  console.log(\"hi, \" + name);\r\n}\r\n\r\ngreetToUser(greetInKorean); // 출력: 성훈님, 안녕하세요\r\ngreetToUser(greetInEnglish); // 출력: hi, 성훈\n</code></pre>\n<ol start=\"2\">\n<li>비동기 처리하기: <code>setTimeout</code> 함수와 같이 첫번 째 인자로 받은 콜백 함수를 받아 일정 시간이 지난 후 해당 콜백 함수를 호출하는 것</li>\n</ol>\n<h2>(복습) 렉시컬 환경과 외부 참조</h2>\n<p>렉시컬 환경은 자바스크립트 엔진이 함수나 블록 코드를 실행하기 위해 필요한 환경 정보를 모아 놓은 객체.</p>\n<ol>\n<li>현재 스코프 내의 변수 및 함수 선언</li>\n<li>외부 환경에 대한 참조 <code>Outer Lexical Environment Reference</code></li>\n</ol>\n<p>자바스크립트는 함수가 어디서 호출되었는지가 아니라, 어디서 정의되었는지를 기준으로 외부 스코프를 결정한다. 함수가 정의된 물리적 위치의 상위 스코프가 해당 함수의 외부 환경 참조 값으로 영구히 저장된다.</p>\n<p>이 외부 참조 값이 바로 클로저 동작 원리가 되는 상위 스코프에 대한 연결 고리가 되며, 이 연결 고리를 따라 상위 스코프 변수에 접근하는 것을 스코프 체인이라고 한다.</p>\n<h2>클로저</h2>\n<p>외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 부른다.</p>\n<p>책에서는 클로저라고 부를 수 있는 2가지 조건을 다음과 같이 나타낸다.</p>\n<pre><code>1. 중첩 함수가 상위 스코프의 식별자를 참조해야 한다.\r\n2. 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정한다.\n</code></pre>\n<ol>\n<li>함수가 외부 스코프의 변수를 참조해야 한다.</li>\n<li>함수가 자신의 정의된 스코프 밖에서 호출되어야 한다.</li>\n</ol>\n<p>즉, 함수가 자신의 렉시컬 환경(정의된 스코프) 밖에서 호출되었을 때, 자신의 렉시컬 환경에 접근할 수 있는 현상.. (외부 참조 값을 통해 변수에 접근한다.)</p>\n<h2>🧐 떡밥회수</h2>\n<p>떡밥 회수의 시간. 이전에 <code>함수와 일급 객체</code>를 공부할 때에, 생성자 함수에 함수를 매개변수로 전달하여 이벤트 발생 시, 부모 요소에 있는 <code>sortOption</code> 값을 변경하는 예제를 기억하는가?</p>\n<pre><code class=\"language-js\">// index.js\r\nlet sortOption = \"최신순\";\r\n\r\nconst sortSelect = new SortSelect(onSortChange);\r\n\r\nfunction onSortChange(newValue) {\r\n  sortOption = newValue; // 부모 상태 갱신\r\n  console.log(\"새 정렬 옵션:\", sortOption);\r\n}\r\n\r\nsortSelect.triggerChange(\"인기순\"); // 자식이 이벤트 발생을 흉내냄\n</code></pre>\n<pre><code class=\"language-js\">// SortSelect.js\r\nfunction SortSelect(onSortChange) {\r\n  // 이벤트 발생 시...\r\n  this.triggerChange = (value) => {\r\n    onSortChange(value); // 부모가 준 콜백 실행\r\n  };\r\n}\n</code></pre>\n<p>클로저는 함수가 정의된 곳과 함수가 실행되는 곳이 물리적으로 분리되었을 때 발생하는 현상이다.</p>\n<ol>\n<li><code>onSortChange</code> 함수가 상위 스코프의 <code>sortOption</code>을 참조한다.</li>\n<li><code>onSortChange</code> 함수는 최상위 스코프에 정의되었지만, 개념적으로 <code>SortSelect</code> 객체의 속성으로 캡슐화되어 보관된다. 함수 실행 주기를 넘어, 인스턴스가 존재하는 한 객체의 생명 주기로 유지된다.</li>\n</ol>\n<h2>결론</h2>\n<p>콜백 함수는 클로저를 사용하는 하나의 방식이고, 클로저가 모두 콜백 함수의 형태를 하고 있는 것은 아니다.</p>\n<ol>\n<li>함수는 정의된 위치의 상위 스코프를 외부 참조값으로 기억한다.</li>\n<li>함수를 다른 함수의 인자로 전달할 수 있으며, 이를 콜백함수라 부른다.</li>\n<li>클로저는 함수가 정의된 스코프 밖에서 호출되더라도, 외부 스코프 변수에 접근할 수 있는 현상이며, 콜백 함수에서 많이 볼 수 있는 패턴이다.</li>\n</ol>\n<p>함수의 다양한 형태를 공부할 때, <code>콜백 함수 == 클로저</code> 라고 얕게 이해하고 넘어갔는데, 이제서야 해당 개념의 차이를 설명할 수 있게 되었다!</p>\n",
    "imagesPath": "/posts/2025-10-30-closure/images/"
  },
  {
    "slug": "0000-ABOUT",
    "title": "TEST",
    "date": "2025-10-20",
    "content": "<h1>딩딩딩딩딩</h1>\n<p><img src=\"/posts/0000-ABOUT/images/cover.png\" alt=\"테스트 이미지\"></p>\n",
    "imagesPath": "/posts/0000-ABOUT/images/"
  },
  {
    "slug": "2025-10-28-TEST",
    "title": "TEST",
    "date": "2025-10-20",
    "summary": "테스트 원",
    "type": "Projects",
    "category": "UX/UI",
    "tags": ["app", "habit", "design"],
    "content": "<h1>마크다운 파일</h1>\n<h2>들어가기 전</h2>\n<p>ㅋㅋ</p>\n<ol>\n<li>넘버링 테스트</li>\n<li>넘버링 테스트</li>\n<li>넘버링 테스트</li>\n</ol>\n<ul>\n<li>닷 테스트</li>\n<li>닷 테스트</li>\n</ul>\n<pre><code class=\"language-js\">// 코드 작성 테스트\r\nconsole.log(\"hello world!\");\n</code></pre>\n<pre><code class=\"language-js\">const run = async () => {\r\n  const posts = await getPosts();\r\n  fs.mkdirSync(path.dirname(OUTPUT), { recursive: true });\r\n  fs.writeFileSync(OUTPUT, JSON.stringify(posts, null, 2));\r\n  console.log(\"✅ posts.json generated:\", OUTPUT);\r\n};\r\n\r\nrun();\n</code></pre>\n<ul>\n<li>[ ] 가나다</li>\n<li>[ ] 가나다</li>\n</ul>\n<p><img src=\"https://i.namu.wiki/i/XDH2CDz5hQ_safBefBCvz7NOl8fiXoMg0HSIqhogw9XczaoE8N6rp9pS6Jz--_w8tX69eXr8NRRzUzUwnT-YPg.webp\" alt=\"이미지 테스트\"></p>\n",
    "imagesPath": "/posts/2025-10-28-TEST/images/"
  },
  {
    "slug": "2025-10-28-TEST2",
    "title": "TEST2",
    "date": "2025-10-29",
    "summary": "테스트 투",
    "type": "Projects",
    "category": "UX/UI",
    "tags": ["app", "habit", "design"],
    "content": "",
    "imagesPath": "/posts/2025-10-28-TEST2/images/"
  },
  {
    "slug": "2025-10-30-closure",
    "title": "[자바스크립트 딥다이브] 24장: 클로저",
    "date": "2025-10-29",
    "summary": "콜백함수, 렉시컬 환경, 외부참조 그리고 클로저 LET'S GO",
    "type": "Blog",
    "category": "Study",
    "tags": ["app", "habit", "design"],
    "content": "<h1>콜백함수, 렉시컬 환경, 외부참조 그리고 클로저 LET'S GO</h1>\n<h2>들어가기 전</h2>\n<p>자바스크립트 딥다이브 24장을 읽기 전, <code>함수와 일급 객체</code>, <code>실행 컨텍스트</code>를 읽으며 함수를 매개변수로 전달하며 생기는 일, 렉시컬 환경과 외부 참조에 대해서 공부했다. 이번에 공부한 <code>클로저</code>는 이전 내용들의 개념을 다시 한 번 복습하면, 완벽히 이해가 될 것 같아 차근차근 공부한 순서대로 글을 작성해보려 한다.</p>\n<h2>(복습) 콜백함수</h2>\n<p>콜백 함수는 자바스크립트에서 함수가 가지는 중요한 특성에서 출발한다. 자바스크립트에서 함수는 숫자, 문자열, 객체 등과 마찬가지로 또 다른 함수의 매개변수로 전달될 수 있다. 이렇게 다른 함수의 인자로 전달되는 함수를 <code>콜백 함수</code>라고 부른다.</p>\n<p>\"야, 내가 함수 하나 전달한테니 나중에 네가 알아서 불러 줘\"</p>\n<pre><code class=\"language-js\">function main(x) {\r\n  x();\r\n}\r\n\r\nfunction sayHi() {\r\n  console.log(\"안녕\");\r\n}\r\n\r\nmain(sayHi); // 출력: 안녕\n</code></pre>\n<p>콜백 함수가 언제, 어떻게 호출될지는 콜백 함수를 전달받은 함수의 내부 구현 사항에 달려 있다. 특히, 코드의 유연성을 높이고 비동기 처리에 강력한 장점을 가진다..</p>\n<ol>\n<li>동적으로 기능을 변경하기: 하나의 함수에 어떤 콜백 함수를 전달하느냐에 따라 마치 부품을 갈아 끼우듯 다른 기능을 수행하는 것</li>\n</ol>\n<pre><code class=\"language-js\">function greetToUser(greet) {\r\n  const name = \"성훈\";\r\n  greet(name);\r\n}\r\n\r\nfunction greetInKorean(name) {\r\n  console.log(name + \"님, 안녕하세요\");\r\n}\r\n\r\nfunction greetInEnglish(name) {\r\n  console.log(\"hi, \" + name);\r\n}\r\n\r\ngreetToUser(greetInKorean); // 출력: 성훈님, 안녕하세요\r\ngreetToUser(greetInEnglish); // 출력: hi, 성훈\n</code></pre>\n<ol start=\"2\">\n<li>비동기 처리하기: <code>setTimeout</code> 함수와 같이 첫번 째 인자로 받은 콜백 함수를 받아 일정 시간이 지난 후 해당 콜백 함수를 호출하는 것</li>\n</ol>\n<h2>(복습) 렉시컬 환경과 외부 참조</h2>\n<p>렉시컬 환경은 자바스크립트 엔진이 함수나 블록 코드를 실행하기 위해 필요한 환경 정보를 모아 놓은 객체.</p>\n<ol>\n<li>현재 스코프 내의 변수 및 함수 선언</li>\n<li>외부 환경에 대한 참조 <code>Outer Lexical Environment Reference</code></li>\n</ol>\n<p>자바스크립트는 함수가 어디서 호출되었는지가 아니라, 어디서 정의되었는지를 기준으로 외부 스코프를 결정한다. 함수가 정의된 물리적 위치의 상위 스코프가 해당 함수의 외부 환경 참조 값으로 영구히 저장된다.</p>\n<p>이 외부 참조 값이 바로 클로저 동작 원리가 되는 상위 스코프에 대한 연결 고리가 되며, 이 연결 고리를 따라 상위 스코프 변수에 접근하는 것을 스코프 체인이라고 한다.</p>\n<h2>클로저</h2>\n<p>외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 부른다.</p>\n<p>책에서는 클로저라고 부를 수 있는 2가지 조건을 다음과 같이 나타낸다.</p>\n<pre><code>1. 중첩 함수가 상위 스코프의 식별자를 참조해야 한다.\r\n2. 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정한다.\n</code></pre>\n<ol>\n<li>함수가 외부 스코프의 변수를 참조해야 한다.</li>\n<li>함수가 자신의 정의된 스코프 밖에서 호출되어야 한다.</li>\n</ol>\n<p>즉, 함수가 자신의 렉시컬 환경(정의된 스코프) 밖에서 호출되었을 때, 자신의 렉시컬 환경에 접근할 수 있는 현상.. (외부 참조 값을 통해 변수에 접근한다.)</p>\n<h2>🧐 떡밥회수</h2>\n<p>떡밥 회수의 시간. 이전에 <code>함수와 일급 객체</code>를 공부할 때에, 생성자 함수에 함수를 매개변수로 전달하여 이벤트 발생 시, 부모 요소에 있는 <code>sortOption</code> 값을 변경하는 예제를 기억하는가?</p>\n<pre><code class=\"language-js\">// index.js\r\nlet sortOption = \"최신순\";\r\n\r\nconst sortSelect = new SortSelect(onSortChange);\r\n\r\nfunction onSortChange(newValue) {\r\n  sortOption = newValue; // 부모 상태 갱신\r\n  console.log(\"새 정렬 옵션:\", sortOption);\r\n}\r\n\r\nsortSelect.triggerChange(\"인기순\"); // 자식이 이벤트 발생을 흉내냄\n</code></pre>\n<pre><code class=\"language-js\">// SortSelect.js\r\nfunction SortSelect(onSortChange) {\r\n  // 이벤트 발생 시...\r\n  this.triggerChange = (value) => {\r\n    onSortChange(value); // 부모가 준 콜백 실행\r\n  };\r\n}\n</code></pre>\n<p>클로저는 함수가 정의된 곳과 함수가 실행되는 곳이 물리적으로 분리되었을 때 발생하는 현상이다.</p>\n<ol>\n<li><code>onSortChange</code> 함수가 상위 스코프의 <code>sortOption</code>을 참조한다.</li>\n<li><code>onSortChange</code> 함수는 최상위 스코프에 정의되었지만, 개념적으로 <code>SortSelect</code> 객체의 속성으로 캡슐화되어 보관된다. 함수 실행 주기를 넘어, 인스턴스가 존재하는 한 객체의 생명 주기로 유지된다.</li>\n</ol>\n<h2>결론</h2>\n<p>콜백 함수는 클로저를 사용하는 하나의 방식이고, 클로저가 모두 콜백 함수의 형태를 하고 있는 것은 아니다.</p>\n<ol>\n<li>함수는 정의된 위치의 상위 스코프를 외부 참조값으로 기억한다.</li>\n<li>함수를 다른 함수의 인자로 전달할 수 있으며, 이를 콜백함수라 부른다.</li>\n<li>클로저는 함수가 정의된 스코프 밖에서 호출되더라도, 외부 스코프 변수에 접근할 수 있는 현상이며, 콜백 함수에서 많이 볼 수 있는 패턴이다.</li>\n</ol>\n<p>함수의 다양한 형태를 공부할 때, <code>콜백 함수 == 클로저</code> 라고 얕게 이해하고 넘어갔는데, 이제서야 해당 개념의 차이를 설명할 수 있게 되었다!</p>\n",
    "imagesPath": "/posts/2025-10-30-closure/images/"
  },
  {
    "slug": "0000-ABOUT",
    "title": "TEST",
    "date": "2025-10-20",
    "content": "<h1>딩딩딩딩딩</h1>\n<p><img src=\"/posts/0000-ABOUT/images/cover.png\" alt=\"테스트 이미지\"></p>\n",
    "imagesPath": "/posts/0000-ABOUT/images/"
  },
  {
    "slug": "2025-10-28-TEST",
    "title": "TEST",
    "date": "2025-10-20",
    "summary": "테스트 원",
    "type": "Projects",
    "category": "UX/UI",
    "tags": ["app", "habit", "design"],
    "content": "<h1>마크다운 파일</h1>\n<h2>들어가기 전</h2>\n<p>ㅋㅋ</p>\n<ol>\n<li>넘버링 테스트</li>\n<li>넘버링 테스트</li>\n<li>넘버링 테스트</li>\n</ol>\n<ul>\n<li>닷 테스트</li>\n<li>닷 테스트</li>\n</ul>\n<pre><code class=\"language-js\">// 코드 작성 테스트\r\nconsole.log(\"hello world!\");\n</code></pre>\n<pre><code class=\"language-js\">const run = async () => {\r\n  const posts = await getPosts();\r\n  fs.mkdirSync(path.dirname(OUTPUT), { recursive: true });\r\n  fs.writeFileSync(OUTPUT, JSON.stringify(posts, null, 2));\r\n  console.log(\"✅ posts.json generated:\", OUTPUT);\r\n};\r\n\r\nrun();\n</code></pre>\n<ul>\n<li>[ ] 가나다</li>\n<li>[ ] 가나다</li>\n</ul>\n<p><img src=\"https://i.namu.wiki/i/XDH2CDz5hQ_safBefBCvz7NOl8fiXoMg0HSIqhogw9XczaoE8N6rp9pS6Jz--_w8tX69eXr8NRRzUzUwnT-YPg.webp\" alt=\"이미지 테스트\"></p>\n",
    "imagesPath": "/posts/2025-10-28-TEST/images/"
  },
  {
    "slug": "2025-10-28-TEST2",
    "title": "TEST2",
    "date": "2025-10-29",
    "summary": "테스트 투",
    "type": "Projects",
    "category": "UX/UI",
    "tags": ["app", "habit", "design"],
    "content": "",
    "imagesPath": "/posts/2025-10-28-TEST2/images/"
  },
  {
    "slug": "2025-10-30-closure",
    "title": "[자바스크립트 딥다이브] 24장: 클로저",
    "date": "2025-10-29",
    "summary": "콜백함수, 렉시컬 환경, 외부참조 그리고 클로저 LET'S GO",
    "type": "Blog",
    "category": "Study",
    "tags": ["app", "habit", "design"],
    "content": "<h1>콜백함수, 렉시컬 환경, 외부참조 그리고 클로저 LET'S GO</h1>\n<h2>들어가기 전</h2>\n<p>자바스크립트 딥다이브 24장을 읽기 전, <code>함수와 일급 객체</code>, <code>실행 컨텍스트</code>를 읽으며 함수를 매개변수로 전달하며 생기는 일, 렉시컬 환경과 외부 참조에 대해서 공부했다. 이번에 공부한 <code>클로저</code>는 이전 내용들의 개념을 다시 한 번 복습하면, 완벽히 이해가 될 것 같아 차근차근 공부한 순서대로 글을 작성해보려 한다.</p>\n<h2>(복습) 콜백함수</h2>\n<p>콜백 함수는 자바스크립트에서 함수가 가지는 중요한 특성에서 출발한다. 자바스크립트에서 함수는 숫자, 문자열, 객체 등과 마찬가지로 또 다른 함수의 매개변수로 전달될 수 있다. 이렇게 다른 함수의 인자로 전달되는 함수를 <code>콜백 함수</code>라고 부른다.</p>\n<p>\"야, 내가 함수 하나 전달한테니 나중에 네가 알아서 불러 줘\"</p>\n<pre><code class=\"language-js\">function main(x) {\r\n  x();\r\n}\r\n\r\nfunction sayHi() {\r\n  console.log(\"안녕\");\r\n}\r\n\r\nmain(sayHi); // 출력: 안녕\n</code></pre>\n<p>콜백 함수가 언제, 어떻게 호출될지는 콜백 함수를 전달받은 함수의 내부 구현 사항에 달려 있다. 특히, 코드의 유연성을 높이고 비동기 처리에 강력한 장점을 가진다..</p>\n<ol>\n<li>동적으로 기능을 변경하기: 하나의 함수에 어떤 콜백 함수를 전달하느냐에 따라 마치 부품을 갈아 끼우듯 다른 기능을 수행하는 것</li>\n</ol>\n<pre><code class=\"language-js\">function greetToUser(greet) {\r\n  const name = \"성훈\";\r\n  greet(name);\r\n}\r\n\r\nfunction greetInKorean(name) {\r\n  console.log(name + \"님, 안녕하세요\");\r\n}\r\n\r\nfunction greetInEnglish(name) {\r\n  console.log(\"hi, \" + name);\r\n}\r\n\r\ngreetToUser(greetInKorean); // 출력: 성훈님, 안녕하세요\r\ngreetToUser(greetInEnglish); // 출력: hi, 성훈\n</code></pre>\n<ol start=\"2\">\n<li>비동기 처리하기: <code>setTimeout</code> 함수와 같이 첫번 째 인자로 받은 콜백 함수를 받아 일정 시간이 지난 후 해당 콜백 함수를 호출하는 것</li>\n</ol>\n<h2>(복습) 렉시컬 환경과 외부 참조</h2>\n<p>렉시컬 환경은 자바스크립트 엔진이 함수나 블록 코드를 실행하기 위해 필요한 환경 정보를 모아 놓은 객체.</p>\n<ol>\n<li>현재 스코프 내의 변수 및 함수 선언</li>\n<li>외부 환경에 대한 참조 <code>Outer Lexical Environment Reference</code></li>\n</ol>\n<p>자바스크립트는 함수가 어디서 호출되었는지가 아니라, 어디서 정의되었는지를 기준으로 외부 스코프를 결정한다. 함수가 정의된 물리적 위치의 상위 스코프가 해당 함수의 외부 환경 참조 값으로 영구히 저장된다.</p>\n<p>이 외부 참조 값이 바로 클로저 동작 원리가 되는 상위 스코프에 대한 연결 고리가 되며, 이 연결 고리를 따라 상위 스코프 변수에 접근하는 것을 스코프 체인이라고 한다.</p>\n<h2>클로저</h2>\n<p>외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 부른다.</p>\n<p>책에서는 클로저라고 부를 수 있는 2가지 조건을 다음과 같이 나타낸다.</p>\n<pre><code>1. 중첩 함수가 상위 스코프의 식별자를 참조해야 한다.\r\n2. 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정한다.\n</code></pre>\n<ol>\n<li>함수가 외부 스코프의 변수를 참조해야 한다.</li>\n<li>함수가 자신의 정의된 스코프 밖에서 호출되어야 한다.</li>\n</ol>\n<p>즉, 함수가 자신의 렉시컬 환경(정의된 스코프) 밖에서 호출되었을 때, 자신의 렉시컬 환경에 접근할 수 있는 현상.. (외부 참조 값을 통해 변수에 접근한다.)</p>\n<h2>🧐 떡밥회수</h2>\n<p>떡밥 회수의 시간. 이전에 <code>함수와 일급 객체</code>를 공부할 때에, 생성자 함수에 함수를 매개변수로 전달하여 이벤트 발생 시, 부모 요소에 있는 <code>sortOption</code> 값을 변경하는 예제를 기억하는가?</p>\n<pre><code class=\"language-js\">// index.js\r\nlet sortOption = \"최신순\";\r\n\r\nconst sortSelect = new SortSelect(onSortChange);\r\n\r\nfunction onSortChange(newValue) {\r\n  sortOption = newValue; // 부모 상태 갱신\r\n  console.log(\"새 정렬 옵션:\", sortOption);\r\n}\r\n\r\nsortSelect.triggerChange(\"인기순\"); // 자식이 이벤트 발생을 흉내냄\n</code></pre>\n<pre><code class=\"language-js\">// SortSelect.js\r\nfunction SortSelect(onSortChange) {\r\n  // 이벤트 발생 시...\r\n  this.triggerChange = (value) => {\r\n    onSortChange(value); // 부모가 준 콜백 실행\r\n  };\r\n}\n</code></pre>\n<p>클로저는 함수가 정의된 곳과 함수가 실행되는 곳이 물리적으로 분리되었을 때 발생하는 현상이다.</p>\n<ol>\n<li><code>onSortChange</code> 함수가 상위 스코프의 <code>sortOption</code>을 참조한다.</li>\n<li><code>onSortChange</code> 함수는 최상위 스코프에 정의되었지만, 개념적으로 <code>SortSelect</code> 객체의 속성으로 캡슐화되어 보관된다. 함수 실행 주기를 넘어, 인스턴스가 존재하는 한 객체의 생명 주기로 유지된다.</li>\n</ol>\n<h2>결론</h2>\n<p>콜백 함수는 클로저를 사용하는 하나의 방식이고, 클로저가 모두 콜백 함수의 형태를 하고 있는 것은 아니다.</p>\n<ol>\n<li>함수는 정의된 위치의 상위 스코프를 외부 참조값으로 기억한다.</li>\n<li>함수를 다른 함수의 인자로 전달할 수 있으며, 이를 콜백함수라 부른다.</li>\n<li>클로저는 함수가 정의된 스코프 밖에서 호출되더라도, 외부 스코프 변수에 접근할 수 있는 현상이며, 콜백 함수에서 많이 볼 수 있는 패턴이다.</li>\n</ol>\n<p>함수의 다양한 형태를 공부할 때, <code>콜백 함수 == 클로저</code> 라고 얕게 이해하고 넘어갔는데, 이제서야 해당 개념의 차이를 설명할 수 있게 되었다!</p>\n",
    "imagesPath": "/posts/2025-10-30-closure/images/"
  }
]
