---
title: "[자바스크립트 딥다이브] 24장: 클로저"
date: "2025-10-29"
summary: "콜백함수, 렉시컬 환경, 외부참조 그리고 클로저 LET'S GO"
type: "Blog"
category: "Study"
tags: ["app", "habit", "design"]
---

# 콜백함수, 렉시컬 환경, 외부참조 그리고 클로저 LET'S GO

## 들어가기 전

자바스크립트 딥다이브 24장을 읽기 전, `함수와 일급 객체`, `실행 컨텍스트`를 읽으며 함수를 매개변수로 전달하며 생기는 일, 렉시컬 환경과 외부 참조에 대해서 공부했다. 이번에 공부한 `클로저`는 이전 내용들의 개념을 다시 한 번 복습하면, 완벽히 이해가 될 것 같아 차근차근 공부한 순서대로 글을 작성해보려 한다.

## (복습) 콜백함수

콜백 함수는 자바스크립트에서 함수가 가지는 중요한 특성에서 출발한다. 자바스크립트에서 함수는 숫자, 문자열, 객체 등과 마찬가지로 또 다른 함수의 매개변수로 전달될 수 있다. 이렇게 다른 함수의 인자로 전달되는 함수를 `콜백 함수`라고 부른다.

"야, 내가 함수 하나 전달한테니 나중에 네가 알아서 불러 줘"

```js
function main(x) {
  x();
}

function sayHi() {
  console.log("안녕");
}

main(sayHi); // 출력: 안녕
```

콜백 함수가 언제, 어떻게 호출될지는 콜백 함수를 전달받은 함수의 내부 구현 사항에 달려 있다. 특히, 코드의 유연성을 높이고 비동기 처리에 강력한 장점을 가진다..

1. 동적으로 기능을 변경하기: 하나의 함수에 어떤 콜백 함수를 전달하느냐에 따라 마치 부품을 갈아 끼우듯 다른 기능을 수행하는 것

```js
function greetToUser(greet) {
  const name = "성훈";
  greet(name);
}

function greetInKorean(name) {
  console.log(name + "님, 안녕하세요");
}

function greetInEnglish(name) {
  console.log("hi, " + name);
}

greetToUser(greetInKorean); // 출력: 성훈님, 안녕하세요
greetToUser(greetInEnglish); // 출력: hi, 성훈
```

2. 비동기 처리하기: `setTimeout` 함수와 같이 첫번 째 인자로 받은 콜백 함수를 받아 일정 시간이 지난 후 해당 콜백 함수를 호출하는 것

## (복습) 렉시컬 환경과 외부 참조

렉시컬 환경은 자바스크립트 엔진이 함수나 블록 코드를 실행하기 위해 필요한 환경 정보를 모아 놓은 객체.

1. 현재 스코프 내의 변수 및 함수 선언
2. 외부 환경에 대한 참조 `Outer Lexical Environment Reference`

자바스크립트는 함수가 어디서 호출되었는지가 아니라, 어디서 정의되었는지를 기준으로 외부 스코프를 결정한다. 함수가 정의된 물리적 위치의 상위 스코프가 해당 함수의 외부 환경 참조 값으로 영구히 저장된다.

이 외부 참조 값이 바로 클로저 동작 원리가 되는 상위 스코프에 대한 연결 고리가 되며, 이 연결 고리를 따라 상위 스코프 변수에 접근하는 것을 스코프 체인이라고 한다.

## 클로저

외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 부른다.

책에서는 클로저라고 부를 수 있는 2가지 조건을 다음과 같이 나타낸다.

```
1. 중첩 함수가 상위 스코프의 식별자를 참조해야 한다.
2. 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정한다.
```

1. 함수가 외부 스코프의 변수를 참조해야 한다.
2. 함수가 자신의 정의된 스코프 밖에서 호출되어야 한다.

즉, 함수가 자신의 렉시컬 환경(정의된 스코프) 밖에서 호출되었을 때, 자신의 렉시컬 환경에 접근할 수 있는 현상.. (외부 참조 값을 통해 변수에 접근한다.)

## 🧐 떡밥회수

떡밥 회수의 시간. 이전에 `함수와 일급 객체`를 공부할 때에, 생성자 함수에 함수를 매개변수로 전달하여 이벤트 발생 시, 부모 요소에 있는 `sortOption` 값을 변경하는 예제를 기억하는가?

```js
// index.js
let sortOption = "최신순";

const sortSelect = new SortSelect(onSortChange);

function onSortChange(newValue) {
  sortOption = newValue; // 부모 상태 갱신
  console.log("새 정렬 옵션:", sortOption);
}

sortSelect.triggerChange("인기순"); // 자식이 이벤트 발생을 흉내냄
```

```js
// SortSelect.js
function SortSelect(onSortChange) {
  // 이벤트 발생 시...
  this.triggerChange = (value) => {
    onSortChange(value); // 부모가 준 콜백 실행
  };
}
```

클로저는 함수가 정의된 곳과 함수가 실행되는 곳이 물리적으로 분리되었을 때 발생하는 현상이다.

1. `onSortChange` 함수가 상위 스코프의 `sortOption`을 참조한다.
2. `onSortChange` 함수는 최상위 스코프에 정의되었지만, 개념적으로 `SortSelect` 객체의 속성으로 캡슐화되어 보관된다. 함수 실행 주기를 넘어, 인스턴스가 존재하는 한 객체의 생명 주기로 유지된다.

## 결론

콜백 함수는 클로저를 사용하는 하나의 방식이고, 클로저가 모두 콜백 함수의 형태를 하고 있는 것은 아니다.

1. 함수는 정의된 위치의 상위 스코프를 외부 참조값으로 기억한다.
2. 함수를 다른 함수의 인자로 전달할 수 있으며, 이를 콜백함수라 부른다.
3. 클로저는 함수가 정의된 스코프 밖에서 호출되더라도, 외부 스코프 변수에 접근할 수 있는 현상이며, 콜백 함수에서 많이 볼 수 있는 패턴이다.

함수의 다양한 형태를 공부할 때, `콜백 함수 == 클로저` 라고 얕게 이해하고 넘어갔는데, 이제서야 해당 개념의 차이를 설명할 수 있게 되었다!
